\begin{description}[leftmargin=-1\labelwidth]
\item[\textsc{Overview}] \lipsum[1]
\item[\textsc{Contents}] \lipsum[2]
\end{description}



\section{Connecting Seriation Methods and Cultural Transmission Models}

In the last two chapters, I described formal models of cultural transmission (Chapter \ref{chap:ct-models}) and the seriation method (Chapter \ref{chap:seriation-methods}) in some detail.  The purpose of this chapter is twofold:  first, to describe the detailed requirements for rendering the output of formal cultural transmission models ``consumable'' by seriation methods, and second, to describe a software framework (\seriationct) used in the remainder of this research for connecting CT models with seriation algorithms.  The detailed requirements will require some explication since although we understand much about the structure of seriation as a chronological method \citep{Dunnell1970,Rouse1967}, the practice of seriation was often informal with much trial and error involved.  In order to construct an algorithm which bridges cultural transmission models with seriation methods, those practices need to be rendered explicit.  

There are four main requirements for connecting simulations of cultural transmission models to seriations of the simulation output.  Algorithms which meet these requirements should allow a simple cultural transmission model, of the type considered in much of the existing archaeological literature, to generate data which are faithful to the structure of archaeological data and archaeological practice in using seriation methods.  First, simulated cultural transmission needs to occur within a simulated spatiotemporal framework which matches the spatial scales and mobility patterns which we are studying.  This requirement is not merely that our cultural transmsision models have a spatial component, since there are many examples of CT models on lattices or graphs; instead, this is also a requirement that the elements of a cultural transmission simulation reflect the spatial and temporal scale and structure of the coarse-grained regional phenomena under study.  Second, simulated cultural transmission events must generate class or type frequencies, not single trait frequencies, since 
\begin{dissparalist}
\item multiple dimensions of variation are necessary to construct classes which have restricted spatiotemporal distributions (whereas individual traits may have very wide distributions)
\item most assemblage-scale seriations are conducted using type or classes as the empirical counting units in the published literature
\end{dissparalist}.
Third, simulated transmission events must be aggregated and sampled in ways that are faithful to the formation processes and recovery history of the actual datasets we seek to explain.  At a minimum, this means accounting for the time averaging that occurs in most accretional contexts and especially with surface collections and bulk excavation units from those deposits.   Fourth, the types or classes by which simulated transmission events are tabulated must be filtered in ways that match the requirements of seriation methods and archaeological practice, to remove types which have degenerate distributions or fail the test of historical significance \citep{Krieger1944}.  

%\clearpage
\input{graphics/fig-seriationct-highlevel}
%\clearpage

In this chapter, I introduce a simulation and analysis framework (called \glslink{glos:seriationct}{SeriationCT}), which implements each requirement and yields simulated data sets which can be seriated using the IDSS algorithm described in Section \ref{sec:idss-seriation} and the paper reprinted in Chapter \ref{chap:paper-idss-seriation}.  The general process for connecting coarse grained simulations of CT and seriations is depicted in Figure \ref{fig:seriationct-highlevel-flow}.  The diagram has placeholders for each of the four requirements described above.  In the next sections, I describe each in detail along with the implementation used in the remainder of this research.  The concluding section of this chapter describes how all of these elements are woven together into a repeatable numerical experiment.  




\section{Regional Temporal Network Models}

Despite its classical interpretation as a relative dating method, seriation is inherently a method for fitting samples of artifact class prevalence values into a spatiotemporal framework describing the flow of variation within a population (see Chapter \ref{chap:seriation-methods} for more details).  Thus, if we seek to model different population structures and determine how seriation solutions are affected, or to infer the best fitting spatiotemporal framework for a given set of archaeological data, a formal means of describing those population structures is required.  The required formalism must be able to represent how individuals are organized into populations at a variety of levels of organization.  It must represent continuous change in that population structure.  And a good formalism must also represent the coarse-grained nature of our data, in which that continuous change is observed through aggregated sets of events with significant duration.   Since the purpose of this spatiotemporal formalism is to represent the intensity of interaction among a structured set of individuals, graphs (in the mathematical sense) are appropriate, if extended to model continuous change and observational aggregation.  In specific, since we want to represent variation in interaction, weighted graphs are the basic building block \citep{Diestel2010a,Harary1969}.  

The ``temporal network'' approach to modeling time-transgressive relationships using graphs allows changes to any aspect of the graph model to be recorded at whatever level of detail required, and thus allows representation of continuous change \citep{Holme2012}.  There are two basic varieties of temporal network model.  The first represents contact events as instantaneous, and thus change in the model is a ``contact sequence'' of events.  The analytic focus in such a model is the \emph{order} of contact events, and how they constrain causal pathways for processes operating on the contact network.  Contact sequence networks are very useful for fine-grained models and research questions, and are widely used for studying contact sequences composed of phone calls, sexual contacts, and other individual-scale, short duration events.  While there may be cases where contact sequence networks could be employed in archaeological problems, in most cases a second class of temporal network models is better suited to time-transgressive archaeological data.  

\input{graphics/fig-interval-temporal-network}

``Interval'' temporal networks represent interactions that occur and persist over a measurable duration as edges that carry time indices.  Interval graphs can be modeled mathematically in a number of ways, but in an algorithmic setting the most convenient is to define a sequence of separate graphs, where each graph $G_t$ in the sequence represents one or more change events within the network between times $t$ and $t + \delta t$ (where $\delta t = t+1 - t$).  In a fully continuous temporal representation, each graph in the sequence specifies a single change event, and thus is equivalent to the way that a continuous-time stochastic process represents events.  In situations where our observations are coarse grained due to time averaging or recovery methods (or both), each graph in the sequence may represent a number of change events which occur over the duration assigned to that graph in the sequence.  


Change events encompass anything that modifies the graph.  Vertices may be added or removed, and edges may be added or removed. In addition to addition and removal, if the graphs in the sequence are weighted, slices may record events where the strength of an edge changes, without other topological changes to the graph.  If other attributes are present on vertices or edges (e.g., labeling edges for a type of interaction), changes to those labelled attributes would also constitute a change event and would be recorded by a graph in the sequence with changed attribute values.  An interval temporal network is thus defined as an ordered set of graph ``slices,'' each slice associated with a time index.  The changes themselves can be found by ``subtracting'' two graph slices and obtaining lists of vertex and edge changes.\footnote{In the \seriationct code repository, the Python class \classname{seriationct.demography.TemporalNetwork} implements an interval temporal network model, taking as input a compressed directory of GML (Graph Modelling Language)\footnote{GML is one of a number of file formats for storing graphs or networks in files.  GML is defined by a standards document located at \url{http://www.infosun.fim.uni-passau.de/Graphlet/GML/gml-tr.html} and is implemented widely by graph libraries and visualization tools.  Crucially, GML is highly extensible, allowing the text files to embed additional edge and vertex attributes which are useful for attaching metadata about the original community pattern and history through the entire experiment, so that it can be used after seriation to help evaluate the accuracy of the seriation results.} files with time indices in the filenames.  The code then provides common operations such as determining which vertices exist at any arbitrary time index, the times at which specific vertices enter or leave the network, and so on.}

Figure \ref{fig:interval-temporal-network} depicts a simple interval temporal network.  Models of this type will be involved in all of the seriation studies in this dissertation, so I will describe it in considerable detail.  The first graph at the top of Figure \ref{fig:interval-temporal-network} represents the starting state of the network in our model, and is composed of two tightly clustered groups of vertices, each densely linked with edges, with two edges interconnecting the clusters.  Whenever an edge or vertex in the model changes, a new graph is recorded.  I refer to these as ``slices,'' since they cut the continuous flow of time and show changes that occur.  Because they record changes in network structure, slices can occur at regular intervals or irregular points in time.  In other words, the duration represented by the pair Slice 1---Slice 2 may be very different than that represented by Slice 3---Slice 4.  This is driven by the underlying processes that are causing vertices and edges to enter, persist, or exit.  

Interval temporal networks like Figure \ref{fig:interval-temporal-network} are sufficient to model regional settlement patterns by treating vertices as communities or subpopulations, as well as individual-scale models where vertices represent individuals who migrate in space and maintain individual patterns of contact with others.  Thus, the temporal network representation is capable of handling the full range of settlement patterns identified by Fuller and Schalk (REFS), including dispersed and mobile communities. \reminder{Need these references in the bibtex}.  In the former, the temporal network would have a smaller number of vertices and slices than in an individual-scale model, but this is irrelevant to the structure of the model.  In any case, cultural transmission models use the edge weights and topology to constrain which individuals interact and thus learn from each other.  

In a regional-scale model, we would typically choose an interpretation where vertices represent communities or subpopulations, and edges as representing the relative amount of migration or transient contact (trade, contact among family members) between communities.  I refer hereafter to a temporal network interpreted in this manner as a ``regional temporal network model'' or RTN model.  In an RTN, the addition of a vertex represents the origin of a new community.  A new community can start through colonization by a subset of individuals from a single ``parent'' community, or by individuals from a number of communities.  Removal of a vertex represents the loss of a community, by any of a number of mechanisms (population decline, death, merging of the community with another).  Similarly, addition of an edge represents the initiation of contact between two communities (which may occur from the establishment of a community), whereas removal of an edge represents its cessation.  Detectable change in the intensity of contact or migration between two communities is represented in the model by a change in the weight applied to an edge.  In the context of sedentary and nucleated Mississippian communities along the central and lower Mississippi River Valley, we will be constructing metapopulation models for cultural transmission (as described Section \ref{sec:ct-models-among-populations}), employing the regional scale interpretation for vertices and edges as described here.

\subsection{Specifying A Regional Temporal Network Model}
\label{sec:specifying-rtn}

\input{graphics/fig-simple-temporal-network-example-gml}

In this section, I describe the details of constructing an RTN model, with a simple example as illustration.  \seriationct uses the Graph Modeling Language (GML) as the basic descriptive language for specifying the structure of the individual graphs which make up an RTN model.\reminder{GML reference and URL}  The format is plain GML with several additional vertex and edge attributes.  In addition to specifying the basic graph properties of nodes and edges, RTN models use these attributes to define how communities evolve between multiple slices, since each slice is a separate GML file. These attributes currently include:

\begin{enumerate}[label=\emph{\arabic*})]
 	\item The geographic position of each community, recorded as X and Y coordinates for each vertex.
 	\item The ``parent'' community, from which migrants give rise to a new community by colonization of the new location.
  \item Optional attributes pertaining to the role of a community in a hierarchical community pattern or complex society.
 \end{enumerate} 

Geographic position is used both for data visualization, and optionally within the \idss seriation algorithm for calculating the geographic significance or cohesiveness of a solution.  The ``parent'' attribute facilitates population continuity (and thus cultural continuity) within simulation models, as new communities are ``born'' within an RTN model over time.  The parent community is the source of individuals and their cultural repertoires with which a new community is seeded when it is added to the regional metapopulation.  The final set of attributes (not discussed in detail here) allow models which specify where communities fit in a settlement hierarchy.  These attributes are not used during simulated cultural transmission itself, since transmission between individuals is governed only by the edge and weight topology of the RTN model, but instead serve as useful ``ground truth'' for scoring the success of a seriation solution at identifying that hierarchical structure given only the simulated output of the CT model.  



Figure \ref{fig:simple-rtn-example} displays a very simple RTN model, with an initial configuration (slice 1) and a single change event (slice 2) in which one vertex (3) is removed, and one vertex is added (4).  Not visible in the figure is the parent-child relationship between the new vertex and an existing community, vertex (1).  The initial configuration is specified in Graph Modelling Language as shown in Listing \ref{listing:slice-001-gml}.

\begin{listing}[!h]
\inputminted{text}{objects/slice-001.gml.txt}
\caption{GML specification for slice 1 in the simple example from Figure \ref{fig:simple-rtn-example}}
\label{listing:slice-001-gml}
\end{listing}

For brevity in the listing, one vertex and one edge are specified, although the others have the same structure.  The change point, slice 2, then has the form given in Listing \ref{listing:slice-002-gml}, again edited to show only the essential portion.
In slice 2, representing the change from slice 1, we can see that vertex 1 persists, recording that it had originated in slice 1 (in the ``appears\_in\_slice'' attribute), and that having existed in the starting configuration it has no ``parent'' community (i.e., ``parent\_node'' equals ``initial'').  In contrast, the newly added vertex 4, records its origin in slice 2, and that it was populated by its parent, vertex 1.  

\begin{listing}[!h]
\inputminted{text}{objects/slice-002.gml.txt}
\caption{GML specification for slice 2 in the simple example from Figure \ref{fig:simple-rtn-example}}
\label{listing:slice-002-gml}
\end{listing}

\subsection{Constructing Regional Temporal Network Models}

The format used to specify RTN models is simple enough that small models can be written by hand using any text editor, or graphs constructed in any graph visualization tool (e.g., Gephi, Cytoscape, Pajek) and exported in GML format.\footnote{When using a graphical tool to construct RTN models, it is important to check whether optional attributes are exported properly, or whether they simply need to be added after the basic structure of the graph is created and exported from a visualization tool.}  In practice, though, we will often be building RTN models in one of several scenarios:

\begin{enumerate}[label=\emph{\arabic*})]
	\item Constructing a model which matches some known or inferred characteristics of an empirical data set, in order to test the hypothesis that a given RTN might represent the coarse-grained pattern of interaction among past communities.
	\item Generating many randomly generated RTN models which share particular structures (e.g., one lineage splitting into several) but otherwise vary in topology, in order to characterize the variation which occurs in seriation results.
\end{enumerate}

In both cases, it is easier to create a software program to build the graphs which compose the RTN model, subject to the constraints of the problem at hand.  \seriationct contains a variety of ``network builder'' programs, especialy to construct classes of RTN models for characterizing whether we can differentiate the underlying structure to regional interaction from seriating the results of cultural transmission between communities.  Each of these network builder programs shares a general algorithmic approach:

\begin{enumerate}[label=\emph{\arabic*})]
	\item Take parameters relating to the number of subpopulations, number of slices, and the type of population structure.
	\item For each slice, construct a randomly chosen graph using the \classname{NetworkX} library, subject to the constraints of the population structure.
	\item For new vertices in each slice, select a parent in the previous slice, subject to the population structure constraints.
	\item Generate random geographic coordinates for all vertices, subject to constraints.
	\item Render each slice as a GML file with the slice number in the filename, into a directory named for the RTN as a whole.  
	\item Output a compressed (ZIP format) archive of the RTN directory.
	\label{alg:generic-network-builder}
\end{enumerate}


\section{Simulating Transmission on a Regional Temporal Network Model}

With a regional temporal network model in hand, we then need to use that model to drive demographic changes within a simulation model of cultural transmission.  This is accomplished in \seriationct by adding custom Python classes to the \simupop  population genetics framework \citep{Peng2005,Peng2012}.  \simupop provides comprehensive support for ``forward time'' modeling, in which populations of simulated individuals are stepped through life cycle events such as reproduction, migration, and selection, to determine the statistical distribution of potential outcomes which may arise from a starting configuration.  In contrast, most simulation in contemporary population genetics is ``retrospective'' or backward-time modeling, in which a current sample is evolved ``backwards'' to estimate aspects of the evolutionary processes which were most likely to have given rise to the current sample.  Kingman's ``coalescent'' and related methods exemplify the retrospective approach \citep{Kingman1977,Wakeley2008}.  

\subsection{\seriationct Simulation Parameters and Batch Configuration}

The current simulation code, \classname{sim-seriationct-networkmodel.py}, implements a neutral Wright-Fisher copying process between individuals within each subpopulation, with innovation in each locus following the infinite-alleles approximation \citep{Kimura1968}.  In that approximation, every innovation (or mutation) creates a new trait at a locus, and there is no ``back mutation'' to existing or previously existing states.  Migration of individuals between subpopulations according to the structure of the RTN model creates the cultural analog to ``gene flow'' within a regional model.  \seriationct simulations  follow a common pattern, regardless of the nature of the experiment or analysis being conducted.  The purpose of this section is to describe this common pattern, the means by which simulations are configured, batches of simulations constructed and executed.  Specific simulation experiments will be described in the chapters and sections for which they serve as experimental tools.  


\subsubsection{Configuring \seriationct Simulations}

\input{tables/seriationct-simulation-parameters}

The main simulation program (\classname{sim-seriationct-networkmodel.py}) takes a number of parameters, described in Table \ref{tab:seriationct-sim-parameters}.  A single simulation run is specified simply by giving values for each of these parameters, and can easily be run from the command line or another program.  Samples of data from the simulated population are stored in an MongoDB database, named for the \classname{experiment} parameter, with the suffix ``\_samples\_raw.''  For example, an experiment named ``neutral\_test'' would yield a database called ``neutral\_test\_samples\_raw.''  

Collections of simulation runs (i.e., experiments) are usually not specified by giving individual parameter values, however, but instead by constructing probability distributions for key parameters and then sampling from these distributions to create specific parameter combinations.  This approach, rather than a selected grid of parameter values, means that distributions of output data values are automatically valid MCMC samples of the posterior distribution for the cultural transmission process being investigated.  This enhances confidence that we have captured the range of dynamic behavior exhibited by a transmission process if we perform enough simulation runs, and allows us to use a large database of simulation output as the basis for model selection or parameter estimation using the approximate Bayesian computation (ABC) approach \citep{Beaumont2002,Beaumont2010,Csillery2010,Marin2012,Sottoriva2010,Toni2009}.  

\begin{listing}[!htp]
\inputminted{json}{objects/seriationct-priors.json}
\caption{Example of uniform prior distributions for two \seriationct simulation parameters}
\label{listing:seriationct-priors}
\end{listing}
 
A set of prior distributions for parameter values is specified in a JSON format file, which is consumed by a program which samples from the distributions specified and outputs a script specifying many individual simulation runs (\classname{seriationct-runbuilder.py}).  Listing \ref{listing:seriationct-priors} shows an example of specifying a uniform distribution on two parameters:  the innovation rate (given as ``theta\_high'' and ``theta\_low''), and the migration fraction.  Other parameter values are given as single values in this example, and are treated as point estimates when constructing batches of simulation runs, and are held constant across the entire batch.

\subsubsection{Constructing Batches of \seriationct Simulations}

\begin{listing}[!htp]
\inputminted{bash}{objects/seriationct-runbuilder-example.sh}
\caption[Example of constructing a batch of \seriationct simulations to run in parallel]{Example of constructing a set of 1000 \seriationct simulations to run in four batches, allowing parallel execution on a typical four core system.}
\label{listing:seriationct-runbuilder}
\end{listing}

The \classname{seriationct-runbuilder.py} program takes a JSON file with point estimates and prior distributions for parameters, as described in the previous section, and creates a specified number of simulation run \emph{commands} which, when executed, perform the actual simulations.  Listing \ref{listing:seriationct-runbuilder} gives an example of using the run builder program to construct 100 simulation runs from the prior distributions given in Listing \ref{listing:seriationct-priors}.
 
The output from the run builder is a set of ``job'' scripts, which are executable shell scripts containing all of the commands needed to execute a set of simulation runs and store the output in a database.  A typical example of such a job script is given in Listing \ref{listing:runbuilder-job}, edited for brevity.  In this example, the point estimates are evident in that they are constant across each command in the job script, while the parameters which have a prior distribution specified are given by randomly chosen values.  Also visible in this example are specific random number seeds, which facilitate exact replication of each simulation run if desired.  The job script thus becomes a primary artifact for replicating any simulation experiment, containing a full record both of the random number generator and all parameters used.  

\begin{listing}[!htp]
\inputminted{bash}{objects/runbuilder-job-output-example.sh}
\caption[Example of job script output by the \classname{seriationct-runbuilder.py} program]{Example of job script output by the \classname{seriationct-runbuilder.py} program, given the command shown in Listing \ref{listing:seriationct-runbuilder}. }
\label{listing:runbuilder-job}
\end{listing}

Parallel execution of simulation runs is controlled by the ``parallelism'' parameter, which specifies the number of job scripts which the run builder will create.  Each job script will have a roughly equivalent number of simulation jobs (equal if the total is divisible by the parallelism parameter).  By default, parallelism is 1, yielding a single job script for execution.  This is most useful for testing and execution of very small batches for pedagogical purposes.  In most real experiments, it is useful to set the parallelism to be equal to the number of CPU cores present on the system, to lower total execution time by executing several simulations in parallel.  This can be done most simply on a Unix-like system (including OS X) by simply launching each job script in the background.\footnote{For example, by appending ``\&'' to the execution:  \classname{sh job-simple-linear-sample-1-af5e3f54-b715-47c7-85b3-66a19ac5724e.sh \&}.}

Large batches of simulation runs, which are common when attempting to capture a large space of parameter variation, benefit from the use of a job scheduler which will manage a pipeline of programs to execute across a set of hardware resources.  The easiest option for users of the Amazon Elastic Compute cloud (EC2) is the \classname{StarCluster} distribution from MIT, available at \url{http://star.mit.edu/cluster/}, which automatically installs the \classname{Grid Engine} job scheduler.  When using a job scheduler, the ``parallelism'' parameter should be set to be a large fraction of the total number of simulation runs, with each job script encapsulating a small number of runs (e.g., 2, 10) since the job script remains the unit of execution across a computing cluster if systems or jobs need to be restarted.  For example, if we schedule 100,000 simulation runs on a computing cluster running \classname{Grid Engine}, we might specify 10 as the ``parallelism'' factor, resulting in 10,000 job scripts, which are then submitted individually to the scheduler.





\subsection{Integrating Regional Temporal Networks With Simulations}

\seriationct adds two major capabilities to \simupop.\footnote{This research was conducted mainly with versions 1.1.4 and 1.1.6 of \simupop.  I continue to verify that \simupop upgrades function properly with the \seriationct code, since the regional temporal network software is useful for a variety of projects beyond this one.}  First, \seriationct adds a sampling module which intersects the traits held at multiple loci to form paradigmatic classes, and stores counts and class richness values from each subpopulation into a database, instead of purely tracking individual trait values.  Second, \seriationct adds the \classname{seriationct.demography.TemporalNetwork} class, which constructs a metapopulation composed of multiple communities with migration probabilities between then, and then evolves this population at change points defined by the slices in an RTN model.  

At each change point defined by an RTN model, the \classname{TemporalNetwork} module:

\begin{enumerate}[label=\emph{\arabic*})]
	\item Determines new subpopulations to be added, and existing subpopulations to be removed.
	\item Determines the parent subpopulation for every new community to be added.
	\item Creates the new subpopulations by fissioning the parent community into two, and then resizing the new and parent subpopulations to the simulation population size.
	\item Deletes the subpopulations (and associated individuals) in any subpopulations targeted for removal.
	\item Updates the migration matrix between subpopulations to be consistent with the edge weights encountered in the current slice of the RTN model.
\end{enumerate}

In addition, in every tick of the simulation model, whether or not the RTN defines a change point, \classname{TemporalNetwork} is responsible for migrating individuals between subpopulations randomly, according to the migration matrix probabilities, and updating global statistics for all subpopulations.  





\section{Constructing Realistic Datasets From Simulation Output}


\section{Seriation of the Simulated Datasets}


\section{Review of \seriationct Analysis Steps}

The analysis steps described in the previous sections allow the construction of numerical experiments whereby the effects of varying a regional interaction model, or aspects of social learning and innovation, on regional-scale seriations of time averaged assemblages can be studied.  The tools which implement each requirement function as a pipeline; each program takes as input the output of a previous tool or program.  The high level, abstract flow for such a numerical experiment was shown in Figure \ref{fig:seriationct-highlevel-flow}, and is refined into greater detail in Figure \ref{fig:seriationct-flow}

Purple circles indicate parameters that must be chosen in order to conduct a specific experiment, yellow boxes represent actual executable program code that implements each step given the parameterization, blue ovals represent intermediate databases or data outputs which become the input to the next step in the processing chain.  The overall result is shown in the green box at the end, and is a set of seriation output data from running the IDSS seriation algorithm on the simulated dataset constructed in previous steps.  

%\clearpage
\input{graphics/fig-seriationct-model-flow}
%\clearpage

The analysis pipeline depicted in Figure \ref{fig:seriationct-flow} is implemented as a set of Python-based command line programs, which are then scripted in an orchestrated sequence to produce replicable results.  In order to construct a simulation experiment within \seriationct, one copies a template directory structure which houses the various intermediate data files, and then customizes a small number of scripts which run phases of the analysis.  It is in these scripts that program options and parameters are set, and these scripts represent a tangible artifact of the analysis encapsulating everything necessary to replicate the experiment.  









% Remove once you write this section...

% \begin{algorithm}[H]
%     \caption{TEST ALGORITHM FOR MAKING SURE IT WORKS IN TOC ETC}
%     \label{alg:wfia-dynamics}
%     \begin{boxedminipage}{\textwidth}
%         \begin{algorithmic}[1]
%             \FORALL{$agents$ in $metapopulation$}
%                 \STATE {$focalagent \leftarrow$ \textsc{GetRandomAgent()}}
%             \ENDFOR 
%         \end{algorithmic}
%     \end{boxedminipage}
% \end{algorithm}


